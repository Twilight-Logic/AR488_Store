//#pragma GCC diagnostic push
//#pragma GCC diagnostic ignored "-Wtype-limits"
//#pragma GCC diagnostic ignored "-Wunused-variable"


#ifdef __AVR__
  #include <avr/wdt.h>
#endif

//#pragma GCC diagnostic pop

#include "AR488_Config.h"
#include "AR488_GPIBdevice.h"
#include "AR488_Layouts.h"


#ifdef USE_INTERRUPTS
  #ifdef __AVR__
    #include <avr/interrupt.h>
  #endif
#endif


#ifdef EN_STORAGE
  #ifdef EN_TEK_4924
    #include "AR488_Store_Tek_4924.h"
  #endif
#endif



#ifdef EN_STORAGE

//------------------------------------------------------------------------------

// file system object
SdFat sd;
SdFile file;
SdFile dirFile;
SdFile rdfile;

// create a serial stream
ArduinoOutStream cout(Serial);

// Number of files found.
uint16_t n = 0;

// Max of 99 files assumed in a single directory
const uint16_t nMax = 99;

// Position of file's directory entry.
uint16_t dirIndex[nMax];

char directory[13] = "/root/";  //allow up to ten character directory names plus two '/' and NULL terminator

char f_name[46];                //the filename variable
char f_type='N';                //the filetype string variable

//enum fType {'P','D','B','S','L','N','O'}; // file types: ASCII Program, ASCII Data, Binary Program or Data, Secret ASCII Program, Last, New (just created), nO file open

const int line_buffer_size = 74;  // 72 char line max in Tek plus CR plus NULL
char buffer[line_buffer_size];
char path[60] = {0};
char dir[11];
char buffr[line_buffer_size];
char buffr2[76];
const int bin_buffer_size = 65;
char binary[33]; // output buffer size = bin buffer size / 2 plus NULL
char *param;
char rparam = '\0';
char ibuffr[4];
char s_input[4] = {0};

const byte numChars = 32;
char receivedChars[numChars];
char tempChars[numChars];        // temporary array for use when parsing

// variables to hold the parsed data
char messageFromPC[numChars] = {0};
char parameterFromPC[numChars] = {0};
int integerFromPC = 0;
float floatFromPC = 0.0;

//------------------------------------------------------------------------------
// store error strings in flash to save RAM
#define error(s) sd.errorHalt(F(s))
//------------------------------------------------------------------------------

boolean newData = false;

//------------------------------------------------------------------------------
void tek_CD(char *direct) {
    // limit the emulator dir name to single level 8 characters trailing "/" plus NULL

    char *param;
    if (direct != NULL) {

        param = strtok(direct, " \t");
        // cout << " \n";
        // set directory = /param/;
        strcpy(directory, "/");
        strcat(directory, param);
        strcat(directory, "/");
        cout << F("directory= ") << directory << " \r " << endl;
    } else {
        cout << F("Null directory");
    }
    f_name[0] = 0; // delete any previous filename that was open
}


//------------------------------------------------------------------------------
void tek_READ_one() {               // Read one data element from currently open file based on data type
    /*
        Tektronix 4050 DATA Types: ASCII and BINARY
        ASCII DATA
        - ASCII Program lines are delimited with CR (unless changed) and files delimited by FF for EOF
        - ASCII Program DATA numeric items are delimited with Space, Comma, Semicolon, Colon, or CR
        - ASCII Program DATA string items are delimited by leading and trailing Quotation Marks or CR
        - To use a Quotation mark inside a character string requires double quotes: ""Help""
        BINARY DATA
        - Each data item contains its own header identifying the length of the item and the type
        - This two byte Header is generated by the talker sending the binary data
        - The two byte data header has the following form:
        MSB                            LSB   MSB                        LSB
        |T3  T2  T1  L13  L12  L11  L10  L9 | L8  L7  L6  L5  L4  L3  L2  L1|
        |           BYTE 1                  |             BYTE 2            |
        L13 to L1 comprise the length of the item including the two header bytes.
        Since all numbers in Tek 4050 BASIC are 8-byte floating point, the binary number data length = 10
        BINARY data types for READ and WRITE commands
        ----------
        T3, T2, T1 are the types of BINARY data
        0   0   0 Unassigned
        0   0   1 Binary number
        0   1   0 Binary string
        0   1   1 Unassigned
        1   0   0 Unassigned
        1   0   1 Unassigned
        1   1   0 Unassigned
        1   1   1 EOF
        Tek 4050 BASIC "TYP" command returns a value based on next item in an open file:
        TYP    Description
        ---    -----------
        0      Empty File or File Not Open
        1      End of File Character
        2      ASCII Numeric Data or Character String
        3      BINARY Numeric Data
        4      BINARY Character String
    */

    char incoming = '\0';
    char CR = '\r';
    strcpy(path, directory);
    strcat(path, f_name);

    ifstream sdin(path);  // initialize stream to beginning of the file

    switch (f_type) {
        case 'P':
            cout << F("ASCII Program\r");
            cout << F("Type SPACE for next item, or type q to quit\r \r ");

            sdin.getline(buffr, line_buffer_size, '\r');          // fetch one CR terminated line of the program
            cout << buffr << '\r';                                // send that line to the serial port

            while (1) {
                while (Serial.available()) {  //any character for next data item or 'q' to quit read1
                    incoming = Serial.read();
                    if (incoming != 'q') {
                        incoming = '\0';     // clear the flag
                        sdin.getline(buffr, line_buffer_size, '\r');          // fetch one CR terminated line of the program
                        if (sdin.eof()) {
                            cout << "__EOF__" << endl;
                            return;
                        }
                        cout << buffr << '\r';                                // send that line to the serial port

                    } else {  // incoming was 'q'
                        incoming = '\0';  // clear the flag
                        cout << "__Quit__" << endl;
                        return;
                    }
                }
            }

            break;

        case 'D':
            cout << F("ASCII DATA file\r");
            cout << F("Type SPACE for next item, or type q to quit\r \r ");

            sdin.getline(buffr, line_buffer_size, '\r');          // fetch one CR terminated line of the program
            cout << buffr << '\r';                                // send that line to the serial port

            while (1) {
                while (Serial.available()) {  //any character for next data item or 'q' to quit read1
                    incoming = Serial.read();
                    if (incoming != 'q') {
                        incoming = '\0';     // clear the flag
                        sdin.getline(buffr, line_buffer_size, '\r');          // fetch one CR terminated line of the program
                        if (sdin.eof()) {
                            cout << "__EOF__" << endl;
                            return;
                        }

                        //no need to parse buffer: 4050 will read a CR terminated buffer and then parse based on BASIC parameter type
                        cout << buffr << '\r';                                // send that line to the serial port

                    } else {  // incoming was 'q'
                        incoming = '\0';  // clear the flag
                        cout << "__Quit__" << endl;
                        return;
                    }
                }
            }
            break;

        case 'B':
            cout << F("BINARY PROGRAM file\r");
            cout << F("Type SPACE for next item, or type q to quit\r \r");

            while (1) {
                while (Serial.available()) {  //any character for next data item or 'q' to quit read1
                    incoming = Serial.read();
                    if (incoming != 'q') {
                        incoming = '\0';     // clear the flag
                        sdin.getline(buffr, bin_buffer_size, '\r');
                        if (strlen(buffr) == 0) {
                            cout << "__EOF__" << endl;
                            return;
                        } else {
                            strcpy(buffr2, buffr);
                            strcat(buffr2, "\r"); //add CR back to buffer, this line was CR terminated;
                        }
                        //convert HEX to binary, output HEX then binary for each buffer

                        int i = 0, len = strlen(buffr2), n = 0;
                        //cout << "Buffer= " << len << " \n";
                        char byt = {0};
                        char tmp[3] = {0, 0, 0};

                        //cout << F("\nHEX: ") << buffr << " \n";
                        //cout << " \n";
                        for (i = 0; i < len - 1; i += 2)
                        {
                            tmp[0] = buffr2[i];
                            tmp[1] = buffr2[i + 1];
                            byt = strtoul(tmp, NULL, 16);
                            cout << byt;
                            //fputc(byt, stdout);
                        }
                        cout << "\r";
                    } else {  // incoming was 'q'
                        incoming = '\0';  // clear the flag
                        cout << "__Quit__" << endl;
                        return;
                    }
                }
            }

            break;

        case 'H':
            cout << F("BINARY DATA file\r");
            cout << F("Type SPACE for next item, or type q to quit\r \r");

            while (1) {
                while (Serial.available()) {  //any character for next data item or 'q' to quit read1
                    incoming = Serial.read();
                    if (incoming != 'q') {
                        incoming = '\0';     // clear the flag
                        sdin.getline(buffr, bin_buffer_size, '\r');
                        if (strlen(buffr) == 0) {
                            cout << "__EOF__" << endl;
                            return;
                        } else {
                            strcpy(buffr2, buffr);
                            strcat(buffr2, "\r"); //add CR back to buffer, this line was CR terminated;
                        }
                        //convert HEX to binary, output HEX then binary for each buffer

                        int i = 0, len = strlen(buffr2), n = 0;
                        //cout << "Buffer= " << len << " \n";
                        char byt = {0};
                        char tmp[3] = {0, 0, 0};

                        //cout << F("\nHEX: ") << buffr << " \n";
                        //cout << " \n";
                        for (i = 0; i < len - 1; i += 2)
                        {
                            tmp[0] = buffr2[i];
                            tmp[1] = buffr2[i + 1];
                            byt = strtoul(tmp, NULL, 16);
                            cout << byt;
                            //fputc(byt, stdout);
                        }
                        cout << "\r";
                    } else {  // incoming was 'q'
                        incoming = '\0';  // clear the flag
                        cout << "__Quit__" << endl;
                        return;
                    }
                }
            }

            break;

        case 'S':
            cout << F("SECRET ASCII PROGRAM file\r");
            cout << F("Type SPACE for next item, or type q to quit\r \r");

            while (1) {
                while (Serial.available()) {  //any character for next data item or 'q' to quit read1
                    incoming = Serial.read();
                    if (incoming != 'q') {
                        incoming = '\0';     // clear the flag
                        sdin.getline(buffr, bin_buffer_size, '\r');
                        /*
                            if (strlen(buffr) == 0) {
                            cout << "__EOF__" << endl;
                            return;
                            } else { */

                        strcpy(buffr2, buffr);
                        strcat(buffr2, "\r"); //add CR back to buffer, this line was CR terminated;

                        //convert HEX to binary, output HEX then binary for each buffer

                        int i = 0, len = strlen(buffr2), n = 0;
                        //cout << "Buffer= " << len << " \n";
                        char byt = {0};
                        char tmp[3] = {0, 0, 0};

                        //cout << F("\nHEX: ") << buffr << " \n";
                        //cout << " \n";
                        for (i = 0; i < len - 1; i += 2)
                        {
                            tmp[0] = buffr2[i];
                            tmp[1] = buffr2[i + 1];
                            byt = strtoul(tmp, NULL, 16);
                            cout << byt;
                            //fputc(byt, stdout);
                        }
                        cout << "\r";
                    } else {  // incoming was 'q'
                        incoming = '\0';  // clear the flag
                        cout << "__Quit__" << endl;
                        return;
                    }
                }
            }

            break;

        case 'L':
            cout << F("LAST file is EMPTY\n");
            break;

        case 'N':
            cout << F("New file - no data\n");
            break;

        case 'O':
            cout << F("No file is open\n");
            break;
    }
    sdin.close();              //close input stream as we have reached EOF
    f_type = 'O';              //set file type to "File Not Open"

}

//------------------------------------------------------------------------------
void tek_READ_file() {              // Read entire currently open file based on file type

    strcpy(path, directory);
    strcat(path, f_name);

    cout << F("File type: ") << f_type << endl;

    ifstream sdin(path);

    switch (f_type) {
        case 'P':
            cout << F("ASCII Program\r \r");

            while (sdin.getline(buffr, line_buffer_size, '\r')) {

                cout << buffr << '\r';
            }
            break;

        case 'D':
            cout << F("ASCII DATA file\r \r");

            while (sdin.getline(buffr, line_buffer_size, '\r')) {

                cout << buffr << '\r';
            }
            break;

        case 'B':
            cout << F("BINARY PROGRAM file\r \r");
            //read entire file - convert HEX bytes to Binary

            while (sdin.getline(buffr, bin_buffer_size, '\r') || sdin.gcount()) {
                if (sdin.fail()) {
                    //cout << F(" \r\nPartial long line\r\n");
                    //sdin.clear(sdin.rdstate() & ~ios_base::failbit);
                } else if (sdin.eof()) {
                    //cout << F(" \r\nPartial final line\r\n");  // sdin.fail() is false
                } else {
                    //cout << F(" \r\nCR terminated line\r\n");
                }
                //convert HEX to binary, output HEX then binary for each buffer

                int i = 0, len = strlen(buffr), n = 0;
                //cout << "Buffer= " << len << " \r\n";
                char byt = {0};
                char tmp[3] = {0, 0, 0};

                //cout << F("\r\nHEX: ") << buffr << " \r\n";
                //cout << " \r\n";
                for (i = 0; i < len - 1; i += 2)
                {
                    tmp[0] = buffr[i];
                    tmp[1] = buffr[i + 1];
                    byt = strtoul(tmp, NULL, 16);
                    cout << byt;
                    //fputc(byt, stdout);
                }
                //fputc(' ', stdout);
                //fputc('\r\n', stdout);
            }
            break;

        case 'H':
            cout << F("BINARY DATA file\r \r");
            // read a buffer of HEX, possibly no termination
            // convert HEX buffer to binary buffer
            // parse for data_type then output the d_type and data

            while (sdin.getline(buffr, bin_buffer_size, '\r') || sdin.gcount()) {
                if (sdin.fail()) {
                    //cout << F(" \r\nPartial long line\r\n");
                    //sdin.clear(sdin.rdstate() & ~ios_base::failbit);
                } else if (sdin.eof()) {
                    //cout << F(" \r\nPartial final line\r\n");  // sdin.fail() is false
                } else {
                    //cout << F(" \r\nCR terminated line\r\n");
                }
                //convert HEX to binary, output HEX then binary for each buffer

                int i = 0, len = strlen(buffr), n = 0;
                //cout << "Buffer= " << len << " \r\n";
                char byt = {0};
                char tmp[3] = {0, 0, 0};

                //cout << F("\r\nHEX: ") << buffr << " \r\n";
                //cout << " \r\n";
                for (i = 0; i < len - 1; i += 2)
                {
                    tmp[0] = buffr[i];
                    tmp[1] = buffr[i + 1];
                    byt = strtoul(tmp, NULL, 16);
                    cout << byt;
                    //fputc(byt, stdout);
                }
                //fputc(' ', stdout);
                //fputc('\r\n', stdout);
            }
            break;

        case 'S':
            cout << F("SECRET ASCII PROGRAM file\r \r");

            while (sdin.getline(buffr, bin_buffer_size, '\r') || sdin.gcount()) {
                if (sdin.fail()) {
                    //cout << F(" \r\nPartial long line\r\n");
                    //sdin.clear(sdin.rdstate() & ~ios_base::failbit);
                } else if (sdin.eof()) {
                    //cout << F(" \r\nPartial final line\r\n");  // sdin.fail() is false
                } else {
                    //cout << F(" \r\nCR terminated line\r\n");
                }
                //convert HEX to binary, output HEX then binary for each buffer

                int i = 0, len = strlen(buffr), n = 0;
                //cout << "Buffer= " << len << " \r\n";
                char byt = {0};
                char tmp[3] = {0, 0, 0};

                //cout << F("\r\nHEX: ") << buffr << " \r\n";
                //cout << " \r\n";
                for (i = 0; i < len - 1; i += 2)
                {
                    tmp[0] = buffr[i];
                    tmp[1] = buffr[i + 1];
                    byt = strtoul(tmp, NULL, 16);
                    cout << byt;
                    //fputc(byt, stdout);
                }
                //fputc(' ', stdout);
                //fputc('\r\n', stdout);
            }
            break;

        case 'L':
            cout << F("LAST file is EMPTY\r \r");
            break;

        case 'N':
            cout << F("New file - no data\n");
            break;

        case 'O':
            cout << F("No file is open\r \r");
            break;
    }
    sdin.close();              //close file as we have reached EOF
    f_type = 'O';              //set file type to "File Not Open"
}

//------------------------------------------------------------------------------
void tek_OLD() {

    strcpy(path, directory);
    strcat(path, f_name);

    // cout << "OLD of file: " << directory << f_name << "  path= " << path << '\r\n' << '\r\n';
    ifstream sdin(path);

    while (sdin.getline(buffer, line_buffer_size, '\r')) {

        cout << buffer << '\r';
    }
    f_type = 'O';  // set file type to NOT OPEN
    file.close();    // and close the current file

    // cout << '\r'; //add one CR to last line processed to end Tek BASIC program output
}

//------------------------------------------------------------------------------

char tek_FIND(char * params) {
    // char f_name[46];  //the filename variable
    /*  FINDs and OPENs file (num)
         Returns: string result= "A" for ASCII, "H" for HEX (Binary or Secret file), "N" for Not Found

         FIND iterates through each file in a directory until filenumber matches num
         since SdFat file index is not sequential with Tek 4050 filenames
    */

    int num = atoi(params);

    if (!dirFile.open(directory, O_RDONLY)) {
        sd.errorHalt("Open directory failed");
    }

    for (int index = 0; index < nMax; index++) { //SdFat file index number

        // while (n < nMax ) {
        file.openNext(&dirFile, O_RDONLY);
        // Skip directories, hidden files, and null files
        if (!file.isSubDir() && !file.isHidden()) {

            file.getName(f_name, 46);

            int filenumber = atoi(f_name);

            if (filenumber == num) {
                // debug print the entire file 'header' with leading space, and CR + DC3 delimiters
                cout << F(" ") << f_name << "\r ";

                // all BINARY files are in HEX format
                if ((f_name[7] == 'B') && (f_name[15] == 'P')) {
                    dirFile.close();  // end of iteration through all files, close directory
                    return 'B'; // BINARY PROGRAM file
                } else if ((f_name[7] == 'B') && (f_name[15] == 'D')) {
                    dirFile.close();  // end of iteration through all files, close directory
                    return 'H'; // BINARY DATA file ** to read - parse the data_type
                } else if (f_name[25] == 'S') {  // f_name[25] is location of file type SECRET ASCII PROGRAM
                    dirFile.close();  // end of iteration through all files, close directory
                    return 'S'; // SECRET ASCII PROGRAM file
                } else if (f_name[15] == 'P') {  // f_name[15] is location of file type (PROG, DATA,...)
                    dirFile.close();  // end of iteration through all files, close directory
                    return 'P'; // ASCII PROGRAM file
                } else if (f_name[7] == 'N') {  // f_name[7] is location of file type (ASCII,BINARY,NEW, or LAST)
                    dirFile.close();  // end of iteration through all files, close directory
                    return 'N'; // ASCII LAST file
                } else if (f_name[7] == 'L') {  // f_name[7] is location of file type (ASCII,BINARY,LAST)
                    dirFile.close();  // end of iteration through all files, close directory
                    return 'L'; // ASCII LAST file
                } else {
                    dirFile.close();  // end of iteration through all files, close directory
                    return 'D'; // ASCII DATA file, also allows other types like TEXT and LOG to be treated as DATA
                }
            }
            //f_name[0]=0; // clear f_name

            if (file.isDir()) {
                // Indicate a directory.
                cout << '/' << endl;
            }

        }
        file.close();  // end of iteration close **this** file

    }
    cout << F("File ") << num << " not found" << endl;
    f_name[0] = '\0';  // clear f_name
    dirFile.close();  // end of iteration through all files, close directory

    return 'O'; // File num NOT OPEN (or NOT FOUND)
}

//------------------------------------------------------------------------------

void tek_TLIST() {
    // char f_name[46];  //the filename variable

    // TLIST must iterate through FILE 1 to LAST file number
    // since SdFat file index is not sequential, code must find first file
    // and iterate to successive files.  This also means process may have to
    // restart at the "0" index to restart search for the next file

    // match the specific Tek4924 tape file number from f_name
    for (int number = 1; number < nMax; number++) { // find each file in # sequence

        //cout << "Directory: " << directory << '\r\n';
        f_name[0] = 0;  // clear f_name, otherwise f_name=last filename
        file.close();  //  close any file that could be open (from previous FIND for example)

        if (!dirFile.open(directory, O_RDONLY)) {
            sd.errorHalt("Open directory failed - possible invalid directory name");
        }
        file.rewind();

        for (int index = 0; index < nMax; index++) { //SdFat file index number

            // while (n < nMax ) {
            file.openNext(&dirFile, O_RDONLY);
            // Skip directories, hidden files, and null files
            if (!file.isSubDir() && !file.isHidden()) {

                file.getName(f_name, 46);

                int filenumber = atoi(f_name);

                if (filenumber == number) {

                    // print the entire file 'header' with leading space, and CR + DC3 delimiters
                    cout << F(" ") << f_name << '\r' << '\x019';

                }
                if ((f_name[7] == 'L') && (filenumber == number)) {
                    // then this is the LAST file - end of TLIST
                    file.close();  // end of iteration close **this** file
                    f_name[0] = 0;  // clear f_name, otherwise f_name=last filename
                    f_type = 'O';    // set file type to "O" for NOT OPEN
                    dirFile.close();  // end of iteration through all files, close directory
                    return;

                } else if (file.isDir()) {
                    // Indicate a directory.
                    cout << '/' << endl;
                }

            }
            file.close();  // end of iteration close **this** file
        }
        f_name[0] = 0;  // clear f_name, otherwise f_name=last filename
        f_type = 'O';    // set file type to "O" for NOT OPEN
        dirFile.close();  // end of iteration through all files, close directory
    }
}


//------------------------------------------------------------------------------

#endif

/***** FWVER "AR488 GPIB Storage, ver. 0.05.31, 15/07/2021" *****/

/*
  Arduino IEEE-488 implementation by John Chajecki

  Inspired by the original work of Emanuele Girlando, licensed under a Creative
  Commons Attribution-NonCommercial-NoDerivatives 4.0 International License.
  Any code in common with the original work is reproduced here with the explicit
  permission of Emanuele Girlando, who has kindly reviewed and tested this code.

  Thanks also to Luke Mester for comparison testing against the Prologix interface.
  AR488 is Licenced under the GNU Public licence.

  Thanks to 'maxwell3e10' on the EEVblog forum for suggesting additional auto mode
  settings and the macro feature.

  Thanks to 'artag' on the EEVblog forum for providing code for the 32u4.
*/

/*
   Implements most of the CONTROLLER functions;
   Substantially compatible with 'standard' Prologix "++" commands
   (see +savecfg command in the manual for differences)

   Principle of operation:
   - Commands received from USB are buffered and whole terminated lines processed
   - Interface commands prefixed with "++" are passed to the command handler
   - Instrument commands and data not prefixed with '++' are sent directly to the GPIB bus.
   - To receive from the instrument, issue a ++read command or put the controller in auto mode (++auto 1|2)
   - Characters received over the GPIB bus are unbuffered and sent directly to USB
   NOTES:
   - GPIB line in a HIGH state is un-asserted
   - GPIB line in a LOW state is asserted
   - The ATMega processor control pins have a high impedance when set as inputs
   - When set to INPUT_PULLUP, a 10k pull-up (to VCC) resistor is applied to the input
*/

/*
   Standard commands

   ++addr         - display/set device address
?   ++auto         - automatically request talk and read response
   ++eoi          - enable/disable assertion of EOI signal
   ++eos          - specify GPIB termination character
   ++eot_enable   - enable/disable appending user specified character to USB output on EOI detection
   ++eot_char     - set character to append to USB output when EOT enabled
   ++lon          - put controller in listen-only mode (listen to all traffic)
   ++read         - read data from instrument
   ++read_tmo_ms  - read timeout specified between 1 - 3000 milliseconds
   ++rst          - reset the controller
   ++savecfg      - save configration
   ++status       - set the status byte to be returned on being polled (bit 6 = RQS, i.e SRQ asserted)
   ++ver          - display firmware version
*/

/*
   Proprietry commands:

   ++default      - set configuration to controller default settings
   ++id name      - show/set the name of the interface
   ++id serial    - show/set the serial number of the interface
   ++id verstr    - show/set the version string (replaces setvstr)
   ++idn          - enable/disable reply to *idn? (disabled by default)
   ++setvstr      - set custom version string (to identify controller, e.g. "GPIB-USB"). Max 47 chars, excess truncated.
   ++ton          - put controller in talk-only mode (send data only)
   ++verbose      - verbose (human readable) mode
*/

/*
   NOT YET IMPLEMENTED

   ++help     - show summary of commands
*/

/*
   For information regarding the GPIB firmware by Emanualle Girlando see:
   http://egirland.blogspot.com/2014/03/arduino-uno-as-usb-to-gpib-controller.html
*/


/*
   Pin mapping between the Arduino pins and the GPIB connector.
   NOTE:
   GPIB pins 10 and 18-24 are connected to GND
   GPIB pin 12 should be connected to the cable shield (might be n/c)
   Pin mapping follows the layout originally used by Emanuelle Girlando, but adds
   the SRQ line (GPIB 10) on pin 2 and the REN line (GPIB 17) on pin 13. The program
   should therefore be compatible with the original interface design but for full
   functionality will need the remaining two pins to be connected.
   For further information about the AR488 see:
*/


/*********************************/
/***** CONFIGURATION SECTION *****/
/***** vvvvvvvvvvvvvvvvvvvvv *****/
// SEE >>>>> Config.h <<<<<
/***** ^^^^^^^^^^^^^^^^^^^^^ *****/
/***** CONFIGURATION SECTION *****/
/*********************************/



/**********************************/
/***** SERIAL PORT MANAGEMENT *****/
/***** vvvvvvvvvvvvvvvvvvvvvv *****/

#ifdef AR_SERIAL_ENABLE
  #ifdef AR_SERIAL_TYPE_SW
    #include <SoftwareSerial.h>
    SoftwareSerial AR_SERIAL_PORT(SW_SERIAL_RX_PIN, SW_SERIAL_TX_PIN);
  #else
    Stream& dataStream = AR_SERIAL_PORT;
  #endif
#endif


#ifdef DB_SERIAL_ENABLE
  #ifdef DB_SERIAL_TYPE_SW
    #include <SoftwareSerial.h>
    SoftwareSerial DB_SERIAL_PORT(SW_SERIAL_RX_PIN, SW_SERIAL_TX_PIN);
  #else
    Stream& debugStream = DB_SERIAL_PORT;
  #endif
#endif


/***** PARSE BUFFERS *****/
/*
 * Note: Ardiono serial input buffer is 64 
 */
// Serial input parsing buffer
static const uint8_t PBSIZE = 128;
char pBuf[PBSIZE];
uint8_t pbPtr = 0;


/***** ^^^^^^^^^^^^^^^^^^^^^^ *****/
/***** SERIAL PORT MANAGEMENT *****/
/**********************************/



/************************************/
/***** COMMON VARIABLES SECTION *****/
/***** vvvvvvvvvvvvvvvvvvvvvvvv *****/

/****** Process status values *****/
#define OK 0
#define ERR 1

/***** Control characters *****/
#define ESC  0x1B   // the USB escape char
#define CR   0xD    // Carriage return
#define LF   0xA    // Newline/linefeed
#define PLUS 0x2B   // '+' character



//extern union AR488conf AR488;



/****** Global variables with volatile values related to controller state *****/

// GPIB bus object
GPIBbus gpibBus;
//Stream& gpibBus(GPIBbus);

// Verbose mode
//bool isVerb = false;

// CR/LF terminated line ready to process
uint8_t lnRdy = 0;      

// GPIB data receive flags
//bool isReading = false;       // Is a GPIB read in progress?
bool autoReading = false;     // GPIB data read in progress
bool readWithEoi = false;     // Read eoi requested
bool readWithEndByte = false; // Read with specified terminator character
bool isQuery = false;         // Direct instrument command is a query
uint8_t tranBrk = 0;          // Transmission break on 1=++, 2=EOI, 3=ATN 4=UNL
uint8_t endByte = 0;          // Termination character

// Device mode - send data
bool snd = false;

// Escaped character flag
bool isEsc = false;           // Charcter escaped
bool isPlusEscaped = false;   // Plus escaped

// Read only mode flag
bool isRO = false;

// Talk only mode flag
bool isTO = false;

// GPIB command parser
bool aTt = false;
bool aTl = false;

// Data send mode flags
bool dataBufferFull = false;    // Flag when parse buffer is full

// State flags set by interrupt being triggered
//extern volatile bool isATN;  // has ATN been asserted?
//extern volatile bool isSRQ;  // has SRQ been asserted?

// SRQ auto mode
bool isSrqa = false;

// Interrupt without handler fired
//volatile bool isBAD = false;

// Whether to run Macro 0 (macros must be enabled)
uint8_t runMacro = 0;

// Send response to *idn?
bool sendIdn = false;


#ifdef EN_STORAGE
  // SD card storage
SDstorage storage;
#endif


/***** ^^^^^^^^^^^^^^^^^^^^^^^^ *****/
/***** COMMON VARIABLES SECTION *****/
/************************************/



/*******************************/
/***** COMMON CODE SECTION *****/
/***** vvvvvvvvvvvvvvvvvvv *****/


/******  Arduino standard SETUP procedure *****/
void setup() {

  // Disable the watchdog (needed to prevent WDT reset loop)
#ifdef __AVR__
  wdt_disable();
#endif

  // Turn off internal LED (set OUPTUT/LOW)
#ifdef LED_BUILTIN
  pinMode(LED_BUILTIN, OUTPUT);
  digitalWrite(LED_BUILTIN, LOW);
#endif

#ifdef USE_INTERRUPTS
  // Turn on interrupts on port
  interruptsEn();
#endif

  // Initialise parse buffer
  flushPbuf();


// Initialise comms port
#ifdef AR_SERIAL_PORT
  AR_SERIAL_PORT.begin(AR_SERIAL_SPEED);
#endif

// Initialise debug port
#ifdef DB_SERIAL_PORT
  DB_SERIAL_PORT.begin(DB_SERIAL_SPEED);
#endif


// Un-comment for diagnostic purposes
/* 
  #if defined(__AVR_ATmega32U4__)
    while(!*arSerial)
    ;
//    Serial.print(F("Starting "));
    for(int i = 0; i < 20; ++i) {  // this gives you 10 seconds to start programming before it crashes
      Serial.print(".");
      delay(500);
    }
    Serial.println("@>");
  #endif // __AVR_ATmega32U4__
*/
// Un-comment for diagnostic purposes


  // Initialise GPIB
  initGpibCfg();

  // SN7516x IC support
#ifdef SN7516X
  pinMode(SN7516X_TE, OUTPUT);
  #ifdef SN7516X_DC
    pinMode(SN7516X_DC, OUTPUT);
  #endif
  // Set listen mode on SN75161/2 (default)
  digitalWrite(SN7516X_TE, HIGH);
  #ifdef SN7516X_DC
    digitalWrite(SN7516X_DC, HIGH);
  #endif
  #ifdef SN7516X_SC
    digitalWrite(SN7516X_SC, LOW);
  #endif
#endif

  // Initialize the interface in device mode
  gpibBus.begin();

//  isATN = false;
//  isSRQ = false;

/*
#ifdef EN_STORAGE
  // setup for SdFat
  // Initialize at the highest speed supported by the board that is
  // not over 50 MHz. Try a lower speed if SPI errors occur.
  if (!sd.begin(SDCARD_CS_PIN, SD_SCK_MHZ(50))) {
    sd.initErrorHalt();
  }
#endif
*/

#ifdef SAY_HELLO
  dataStream.print(F("AR488-Store ready "));
  if (gpibBus.cfg.cmode==1) dataStream.println(F("(device)."));
#endif

  
}
/****** End of Arduino standard SETUP procedure *****/


/***** ARDUINO MAIN LOOP *****/
void loop() {
/*
debugStream.println("LOOP");
debugStream.print(F("LnRdy: "));
debugStream.println(lnRdy);
*/

/*** Pin Hooks ***/
/*
 * Not all boards support interrupts or have PCINTs. In this
 * case, use in-loop checking to detect when SRQ and ATN have 
 * been signalled
 */
#ifndef USE_INTERRUPTS
//  isATN = (digitalRead(ATN)==LOW ? true : false);
//  isSRQ = (digitalRead(SRQ)==LOW ? true : false);
#endif
  /*** In loop serial buffer checking ***/
  /* SerialEvent() handles the serial interrupt but some boards
     do not support SerialEvent. In this case use in-loop checking
  */
/*  
#if not defined (USE_SERIALEVENT) || not defined (SERIALEVENT1) || not defined (SERIALEVENT2) || not defined (SERIALEVENT3)
  // Serial input handler
  while (dataStream.available()) {
    lnRdy = parseInput(dataStream.read());
  }
#endif
*/
//
/*** Process the buffer ***/
/* Each received char is passed through parser until an un-escaped 
 * CR is encountered. If we have a command then parse and execute.
 * If the line is data (inclding direct instrument commands) then
 * send it to the instrument.
 * NOTE: parseInput() sets lnRdy in serialEvent, readBreak or in the
 * above loop
 * lnRdy=1: process command;
 * lnRdy=2: send data to Gpib
 */

  // lnRdy=1: received a command so execute it...
  if (lnRdy == 1) {
    execCmd(pBuf, pbPtr);
  }


  // Device mode:
  if (isTO) {
    if (lnRdy == 2) sendToInstrument(pBuf, pbPtr);
  }else if (isRO) {
    lonMode();
  }else{
    if (gpibBus.isAsserted(ATN)) attnRequired();
    if (lnRdy == 2) sendToInstrument(pBuf, pbPtr);
  }


  // Reset line ready flag
//  lnRdy = 0;

  // IDN query ?
  if (sendIdn) {
    if (gpibBus.cfg.idn==1) dataStream.println(gpibBus.cfg.sname);
    if (gpibBus.cfg.idn==2) {dataStream.print(gpibBus.cfg.sname);dataStream.print("-");dataStream.println(gpibBus.cfg.serial);}
    sendIdn = false;
  }

  // Check serial buffer
  lnRdy = serialIn_h();
  
  delayMicroseconds(5);
}
/***** END MAIN LOOP *****/


void initGpibCfg(){
  // Set default values from Config_h
  // ({'\0'} sets version string array to null)
  gpibBus.cfg = { GPIB_EOT_ENABLE,
                  GPIB_EOI_ENABLE,
                  1,                // Device mode
                  GPIB_ADDRESS,     // This interface address
                  GPIB_ADDRESS,     // Primary address to use when addressing instrument
                  0,                // Secondary address to use when addressing instrument
                  GPIB_EOS_MODE,
                  0,                // Status byte
                  GPIB_AUTO_MODE,
                  GPIB_RTMO,
                  GPIB_EOT_CHAR,
                  {'\0'},           // Custom version string
                  GPIB_EOR_MODE,
                  {'\0'},           // Interface short name
                  0,                // Interface serial
                  0                 // Send IDN (0-disable, 1-yes,name or 2-yes,name+serial)?
        }; 
}


/***** Serial event handler *****/
/*
 * Note: the Arduino serial buffer is 64 characters long. Characters are stored in
 * this buffer until serialEvent_h() is called. parsedInput() takes a character at 
 * a time and places it into the 256 character parse buffer whereupon it is parsed
 * to determine whether a command or data are present.
 * lnRdy=0: terminator not detected yet
 * lnRdy=1: terminator detected, sequence in parse buffer is a ++ command
 * lnRdy=2: terminator detected, sequence in parse buffer is data or direct instrument command
 */ 
uint8_t serialIn_h() {
  uint8_t bufferStatus = 0;
  // Parse serial input until we have detected a line terminator
  while (dataStream.available() && bufferStatus==0) {   // Parse while characters available and line is not complete
    bufferStatus = parseInput(dataStream.read());
  }

#ifdef DEBUG_SERIAL_INPUT
  if (bufferStatus) {
    debugStream.print(F("BufferStatus: "));
    debugStream.println(bufferStatus);  
  }
#endif

  return bufferStatus;
}


/*************************************/
/***** Device operation routines *****/
/*************************************/


/***** Unrecognized command *****/
void errBadCmd() {
  dataStream.println(F("Unrecognized command"));
}


/***** Add character to the buffer and parse *****/
uint8_t parseInput(char c) {

  uint8_t r = 0;

  // Read until buffer full (buffer-size - 2 characters)
  if (pbPtr < PBSIZE) {
//    if (isVerb) dataStream.print(c);  // Humans like to see what they are typing...
    // Actions on specific characters
    switch (c) {
      // Carriage return or newline? Then process the line
      case CR:
      case LF:
        // If escaped just add to buffer
        if (isEsc) {
          addPbuf(c);
          isEsc = false;
        } else {
          // Carriage return on blank line?
          // Note: for data CR and LF will always be escaped
          if (pbPtr == 0) {
            flushPbuf();
//            if (isVerb) showPrompt();
            return 0;
          } else {
//            if (isVerb) dataStream.println();  // Move to new line
#ifdef DEBUG_CMD_PARSER
            debugStream.print(F("parseInput: Received ")); debugStream.println(pBuf);
#endif
            // Buffer starts with ++ and contains at least 3 characters - command?
            if (pbPtr>2 && isCmd(pBuf) && !isPlusEscaped) {
              // Exclamation mark (break read loop command)
              if (pBuf[2]==0x21) {
                r = 3;
                flushPbuf();
              // Otherwise flag command received and ready to process 
              }else{
                r = 1;
              }
            // Buffer contains *idn? query and interface to respond
            }else if (pbPtr>3 && gpibBus.cfg.idn>0 && isIdnQuery(pBuf)){
              sendIdn = true;
              flushPbuf();
            // Buffer has at least 1 character = instrument data to send to gpib bus
            }else if (pbPtr > 0) {
              r = 2;
            }
            isPlusEscaped = false;
#ifdef DEBUG_CMD_PARSER
            debugStream.print(F("R: "));debugStream.println(r);
#endif
//            return r;
          }
        }
        break;
      case ESC:
        // Handle the escape character
        if (isEsc) {
          // Add character to buffer and cancel escape
          addPbuf(c);
          isEsc = false;
        } else {
          // Set escape flag
          isEsc  = true;  // Set escape flag
        }
        break;
      case PLUS:
        if (isEsc) {
          isEsc = false;
          if (pbPtr < 2) isPlusEscaped = true;
        }
        addPbuf(c);
//        if (isVerb) dataStream.print(c);
        break;
      // Something else?
      default: // any char other than defined above
//        if (isVerb) dataStream.print(c);  // Humans like to see what they are typing...
        // Buffer contains '++' (start of command). Stop sending data to serial port by halting GPIB receive.
        addPbuf(c);
        isEsc = false;
    }
  }
  if (pbPtr >= PBSIZE) {
    if (isCmd(pBuf) && !r) {  // Command without terminator and buffer full
/*      
      if (isVerb) {
        dataStream.println(F("ERROR - Command buffer overflow!"));
      }
*/      
      flushPbuf();
    }else{  // Buffer contains data and is full, so process the buffer (send data via GPIB)
      dataBufferFull = true;
      // Signal to GPIB object that more data will follow (suppress GPIB addressing)
//      gpibBus.setDataContinuity(true);

      r = 2;
    }
  }
  return r;
}


/***** Is this a command? *****/
bool isCmd(char *buffr) {
  if (buffr[0] == PLUS && buffr[1] == PLUS) {
#ifdef DEBUG_CMD_PARSER
    debugStream.println(F("isCmd: Command detected."));
#endif
    return true;
  }
  return false;
}


/***** Is this an *idn? query? *****/
bool isIdnQuery(char *buffr) {
//  if (buffr[0] == PLUS && buffr[1] == PLUS) {
  if (strncmp(buffr, "*idn?", 5)==0) {
#ifdef DEBUG_CMD_PARSER
    debugStream.println(F("isIdnQuery: Detected IDN query."));
#endif
    return true;
  }
  return false;
}


/***** ++read command detected? *****/
bool isRead(char *buffr) {
  char cmd[4];
  // Copy 2nd to 5th character
  for (int i = 2; i < 6; i++) {
    cmd[i - 2] = buffr[i];
  }
  // Compare with 'read'
  if (strncmp(cmd, "read", 4) == 0) return true;
  return false;
}


/***** Add character to the buffer *****/
void addPbuf(char c) {
  pBuf[pbPtr] = c;
  pbPtr++;
}


/***** Clear the parse buffer *****/
void flushPbuf() {
  memset(pBuf, '\0', PBSIZE);
  pbPtr = 0;
}


struct cmdRec { 
  const char* token; 
  void (*handler)(char *);
};


static cmdRec cmdHidx [] = { 
 
  { "addr",        addr_h      }, 
  { "auto",        amode_h     },
//  { "default",     (void(*)(char*)) default_h },
//  { "eoi",         eoi_h       },
//  { "eor",         eor_h       },
//  { "eos",         eos_h       },
//  { "eot_char",    eot_char_h  },
//  { "eot_enable",  eot_en_h    },
  { "id",          id_h        },
  { "idn",         idn_h       },
  { "lon",         lon_h       },
//  { "macro",       macro_h     },
//  { "mode" ,       cmode_h     },
  { "read",        read_h      },
  { "read_tmo_ms", rtmo_h      },
  { "repeat",      repeat_h    },
  { "rst",         (void(*)(char*)) rst_h },
//  { "savecfg",     (void(*)(char*)) save_h },
  { "setvstr",     setvstr_h   },
  { "status",      stat_h      },
#ifdef EN_STORAGE
//  { "storage",     store_h     },
#endif
  { "ton",         ton_h       },
  { "ver",         ver_h       },
//  { "verbose",     (void(*)(char*)) verb_h    },
//  { "tmbus",       tmbus_h     },
#ifdef EN_STORAGE  
  // Tek 4924 commands using Prologix ++ format
  { "find",        (void(*)(char*)) tek_FIND  },
  { "tlist",       (void(*)(char*)) tek_TLIST },
  { "cd",          cd_h        },
  { "readf",       readf_h     },
  { "read1",       read1_h     },
  { "help",        help_h      },  //help for Tek 4924 commands
  { "old",         old_h       },
#endif
  { "xdiag",       xdiag_h     }
};

void find_h(char * params){
}

void tlist_h(char * params){
}

void cd_h(char * params){
}

void readf_h(char * params){
}

void read1_h(char * params){
}

void help_h(char * params){
}

void old_h(char * params){
}


/***** Show a prompt *****/
void showPrompt() {
  // Print prompt
  dataStream.print("> ");
}


/****** Send data to instrument *****/
/* Processes the parse buffer whenever a full CR or LF
 * and sends data to the instrument
 */
void sendToInstrument(char *buffr, uint8_t dsize) {

#ifdef DEBUG_SEND_TO_INSTR
  if (buffr[dsize] != LF) debugStream.println();
  debugStream.print(F("sendToInstrument: Received for sending: "));
  printHex(buffr, dsize);
#endif

  // Is this an instrument query command (string ending with ?)
  if (buffr[dsize-1] == '?') isQuery = true;

  // Address device
//  if (!gpibBus.isDeviceAddressed()) gpibBus.addressDevice(gpibBus.cfg.paddr, LISTEN);

  // Send string to instrument
  gpibBus.sendData(buffr, dsize, true);

  // Address device
/*  
  if (dataBufferFull) {
    dataBufferFull = false;
  }else{
    gpibBus.unAddressDevice();
  }
*/

#ifdef DEBUG_SEND_TO_INSTR
  debugStream.println(F("sendToInstrument: Sent."));
#endif
 
  // Show a prompt on completion?
/*  
  if (isVerb) {
      showPrompt();
  }
*/

  // Flush the parse buffer
  flushPbuf();
  lnRdy = 0;
}


/***** Execute a command *****/
void execCmd(char *buffr, uint8_t dsize) {
  char line[PBSIZE];

  // Copy collected chars to line buffer
  memcpy(line, buffr, dsize);

  // Flush the parse buffer
  flushPbuf();
  lnRdy = 0;

#ifdef DEBUG_CMD_PARSER
  debugStream.print(F("execCmd: Command received: ")); printHex(line, dsize);
#endif

  // Its a ++command so shift everything two bytes left (ignore ++) and parse
  for (int i = 0; i < dsize-2; i++) {
    line[i] = line[i + 2];
  }
  // Replace last two bytes with a null (\0) character
  line[dsize - 2] = '\0';
  line[dsize - 1] = '\0';
#ifdef DEBUG_CMD_PARSER
  debugStream.print(F("execCmd: Sent to the command processor: ")); printHex(line, dsize-2);
#endif
  // Execute the command
//  if (isVerb) dataStream.println(); // Shift output to next line
  getCmd(line);

  // Show a prompt on completion?
//  if (isVerb) showPrompt();
}


/***** Extract command and pass to handler *****/
void getCmd(char *buffr) {

  char *token;  // Pointer to command token
  char *params; // Pointer to parameters (remaining buffer characters)
  
  int casize = sizeof(cmdHidx) / sizeof(cmdHidx[0]);
  int i = 0;

#ifdef DEBUG_CMD_PARSER
  debugStream.print("getCmd: ");
  debugStream.print(buffr); debugStream.print(F(" - length:")); debugStream.println(strlen(buffr));
#endif

  // If terminator on blank line then return immediately without processing anything 
  if (buffr[0] == 0x00) return;
  if (buffr[0] == CR) return;
  if (buffr[0] == LF) return;

  // Get the first token
  token = strtok(buffr, " \t");

#ifdef DEBUG_CMD_PARSER
  debugStream.print("getCmd: process token: "); debugStream.println(token);
#endif

  // Check whether it is a valid command token
  i = 0;
  do {
    if (strcasecmp(cmdHidx[i].token, token) == 0) break;
    i++;
  } while (i < casize);

  if (i < casize) {
    // We have found a valid command and handler
#ifdef DEBUG_CMD_PARSER
    debugStream.print("getCmd: found handler for: "); debugStream.println(cmdHidx[i].token);
#endif
    // If command is found then execute it
    // If its a command with parameters
    // Copy command parameters to params and call handler with parameters
    params = token + strlen(token) + 1;
  
    // If command parameters were specified
    if (strlen(params) > 0) {
#ifdef DEBUG_CMD_PARSER
      debugStream.print(F("Calling handler with parameters: ")); debugStream.println(params);
#endif
      // Call handler with parameters specified
      cmdHidx[i].handler(params);
        
    }else{
      // Call handler without parameters
      cmdHidx[i].handler(NULL);
    }
  } else {
    // No valid command found
    errBadCmd();
  }
}


/***** Prints charaters as hex bytes *****/
void printHex(char *buffr, int dsize) {
#ifdef DB_SERIAL_ENABLE
  for (int i = 0; i < dsize; i++) {
    debugStream.print(buffr[i], HEX); debugStream.print(" ");
  }
  debugStream.println();
#endif
}


/***** Check whether a parameter is in range *****/
/* Convert string to integer and check whether value is within
 * lowl to higl inclusive. Also returns converted text in param
 * to a uint16_t integer in rval. Returns true if successful, 
 * false if not
*/
bool notInRange(char *param, uint16_t lowl, uint16_t higl, uint16_t &rval) {

  // Null string passed?
  if (strlen(param) == 0) return true;

  // Convert to integer
  rval = 0;
  rval = atoi(param);

  // Check range
  if (rval < lowl || rval > higl) {
    errBadCmd();
/*    
    if (isVerb) {
      dataStream.print(F("Valid range is between "));
      dataStream.print(lowl);
      dataStream.print(F(" and "));
      dataStream.println(higl);
    }
*/    
    return true;
  }
  return false;
}


/*************************************/
/***** STANDARD COMMAND HANDLERS *****/
/*************************************/

/***** Show or change device address *****/
void addr_h(char *params) {
  //  char *param, *stat;
//  char *param;
  uint16_t val;
  if (params != NULL) {

    // Primary address
//    param = strtok(params, " \t");
//    if (notInRange(param, 1, 30, val)) return;
    if (notInRange(params, 1, 30, val)) return;
    if (val == gpibBus.cfg.caddr) {
      errBadCmd();
//      if (isVerb) dataStream.println(F("That is my address! Address of a remote device is required."));
      return;
    }
    gpibBus.cfg.paddr = val;
/*  
    if (isVerb) {
      dataStream.print(F("Set device primary address to: "));
      dataStream.println(val);
    }
*/
/*
    // Secondary address
    gpibBus.cfg.saddr = 0;
    val = 0;
    param = strtok(NULL, " \t");
    if (param != NULL) {
      if (notInRange(param, 96, 126, val)) return;
      gpibBus.cfg.saddr = val;
      if (isVerb) {
        dataStream.print("Set device secondary address to: ");
        dataStream.println(val);
      }
    }
*/

  } else {
//    dataStream.print(gpibBus.cfg.paddr);
    dataStream.println(gpibBus.cfg.paddr);
/*    
    if (gpibBus.cfg.saddr > 0) {
      dataStream.print(F(" "));
      dataStream.print(gpibBus.cfg.saddr);
    }
    dataStream.println();
*/
  }
}


/***** Show or set read timout *****/
void rtmo_h(char *params) {
  uint16_t val;
  if (params != NULL) {
    if (notInRange(params, 1, 32000, val)) return;
    gpibBus.cfg.rtmo = val;
/*    
    if (isVerb) {
      dataStream.print(F("Set [read_tmo_ms] to: "));
      dataStream.print(val);
      dataStream.println(F(" milliseconds"));
    }
*/    
  } else {
    dataStream.println(gpibBus.cfg.rtmo);
  }
}


/***** Show or set end of send character *****/
/*
void eos_h(char *params) {
  uint16_t val;
  if (params != NULL) {
    if (notInRange(params, 0, 3, val)) return;
    AR488.eos = (uint8_t)val;
   
    if (isVerb) {
      dataStream.print(F("Set EOS to: "));
      dataStream.println(val);
    };
    
  } else {
    dataStream.println(AR488.eos);
  }
}
*/


/***** Show or set EOI assertion on/off *****/
/*
void eoi_h(char *params) {
  uint16_t val;
  if (params != NULL) {
    if (notInRange(params, 0, 1, val)) return;
    AR488.eoi = val ? true : false;
   
    if (isVerb) {
      dataStream.print(F("Set EOI assertion: "));
      dataStream.println(val ? "ON" : "OFF");
    };

  } else {
    dataStream.println(AR488.eoi);
  }
}
*/


/***** Show or enable/disable sending of end of transmission character *****/
/*
void eot_en_h(char *params) {
  uint16_t val;
  if (params != NULL) {
    if (notInRange(params, 0, 1, val)) return;
    AR488.eot_en = val ? true : false;
    
    if (isVerb) {
      dataStream.print(F("Appending of EOT character: "));
      dataStream.println(val ? "ON" : "OFF");
    }
    
  } else {
    dataStream.println(AR488.eot_en);
  }
}
*/


/***** Show or set end of transmission character *****/
/*
void eot_char_h(char *params) {
  uint16_t val;
  if (params != NULL) {
    if (notInRange(params, 0, 255, val)) return;
    AR488.eot_ch = (uint8_t)val;
    
    if (isVerb) {
      dataStream.print(F("EOT set to ASCII character: "));
      dataStream.println(val);
    };
    
  } else {
    dataStream.println(AR488.eot_ch, DEC);
  }
}
*/


/***** Show or enable/disable auto mode *****/
void amode_h(char *params) {
  uint16_t val;
  if (params != NULL) {
    if (notInRange(params, 0, 3, val)) return;
/*   
    if (val > 0 && isVerb) {
      dataStream.println(F("WARNING: automode ON can cause some devices to generate"));
      dataStream.println(F("         'addressed to talk but nothing to say' errors"));
    }
*/    
    gpibBus.cfg.amode = (uint8_t)val;
    if (gpibBus.cfg.amode < 3) autoReading = false;
/*    
    if (isVerb) {
      dataStream.print(F("Auto mode: "));
      dataStream.println(gpibBus.cfg.amode);
    }
*/    
  } else {
    dataStream.println(gpibBus.cfg.amode);
  }
}



/***** Display the controller version string *****/
void ver_h(char *params) {
  // If "real" requested
  if (params != NULL && strncasecmp(params, "real", 3) == 0) {
    dataStream.println(F(FWVER));
    // Otherwise depends on whether we have a custom string set
  } else {
    if (strlen(gpibBus.cfg.vstr) > 0) {
      dataStream.println(gpibBus.cfg.vstr);
    } else {
      dataStream.println(F(FWVER));
    }
  }
}


/***** Address device to talk and read the sent data *****/
void read_h(char *params) {
  // Clear read flags
  readWithEoi = false;
  readWithEndByte = false;
  endByte = 0;
  // Read any parameters
  if (params != NULL) {
    if (strlen(params) > 3) {
//      if (isVerb) dataStream.println(F("Invalid termination character - ignored!")); void addr_h(char *params);
    } else if (strncmp(params, "eoi", 3) == 0) { // Read with eoi detection
      readWithEoi = true;
    } else { // Assume ASCII character given and convert to an 8 bit byte
      readWithEndByte = true;
      endByte = atoi(params);
    }
  }
  if (gpibBus.cfg.amode == 3) {
    // In auto continuous mode we set this flag to indicate we are ready for continuous read
    autoReading = true;
  } else {
    // If auto mode is disabled we do a single read
    gpibBus.receiveData(dataStream, readWithEoi, readWithEndByte, endByte);
  }
}


/***** Reset the controller *****/
/*
 * Arduinos can use the watchdog timer to reset the MCU
 * For other devices, we restart the program instead by
 * jumping to address 0x0000. This is not a hardware reset
 * and will not reset a crashed MCU, but it will re-start
 * the interface program and re-initialise all parameters. 
 */
void rst_h() {
#ifdef WDTO_1S
  // Where defined, reset controller using watchdog timeout
  unsigned long tout;
  tout = millis() + 2000;
  wdt_enable(WDTO_1S);
  while (millis() < tout) {};
  // Should never reach here....
/*  
  if (isVerb) {
    dataStream.println(F("Reset FAILED."));
  };
*/  
#else
  // Otherwise restart program (soft reset)
  asm volatile ("  jmp 0");
#endif
}


/***** Set the status byte (device mode) *****/
void stat_h(char *params) {
  uint16_t val = 0;
  // A parameter given?
  if (params != NULL) {
    // Byte value given?
    if (notInRange(params, 0, 255, val)) return;
    gpibBus.setStatus((uint8_t)val);
  } else {
    // Return the currently set status byte
    dataStream.println(gpibBus.cfg.stat);
  }
}


/***** Save controller configuration *****/
/*
void save_h() {
#ifdef E2END
  epWriteData(AR488.db, AR_CFG_SIZE);
//  if (isVerb) dataStream.println(F("Settings saved."));
#else
  dataStream.println(F("EEPROM not supported."));
#endif
}
*/

/***** Show state or enable/disable listen only mode *****/
void lon_h(char *params) {
  uint16_t val;
  if (params != NULL) {
    if (notInRange(params, 0, 1, val)) return;
    isRO = val ? true : false;
    if (isTO) isTO = false; // Talk-only mode must be disabled!
/*    
    if (isVerb) {
      dataStream.print(F("LON: "));
      dataStream.println(val ? "ON" : "OFF") ;
    }
*/    
  } else {
    dataStream.println(isRO);
  }
}


/***********************************/
/***** CUSTOM COMMAND HANDLERS *****/
/***********************************/

/***** Re-load default configuration *****/
/*
void default_h() {
  gpibInit();
}
*/


/***** Show or set end of receive character(s) *****/
/*
void eor_h(char *params) {
  uint16_t val;
  if (params != NULL) {
    if (notInRange(params, 0, 15, val)) return;
    AR488.eor = (uint8_t)val;
   
    if (isVerb) {
      dataStream.print(F("Set EOR to: "));
      dataStream.println(val);
    };
   
  } else {
    if (AR488.eor>7) AR488.eor = 0;  // Needed to reset FF read from EEPROM after FW upgrade
    dataStream.println(AR488.eor);
  }
}
*/


/***** Enable verbose mode 0=OFF; 1=ON *****/
/*
void verb_h() {
  isVerb = !isVerb;
  dataStream.print("Verbose: ");
  dataStream.println(isVerb ? "ON" : "OFF");
}
*/

/***** Set version string *****/
/* Replace the standard AR488 version string with something else
 *  NOTE: some instrument software requires a sepcific version string to ID the interface
 */
void setvstr_h(char *params) {
  uint8_t plen;
  char idparams[64];
  plen = strlen(params);
  memset(idparams, '\0', 64);
  strncpy(idparams, "verstr ", 7);
  strncat(idparams, params, plen);


  id_h(idparams);

}


/***** Talk only mode *****/
void ton_h(char *params) {
  uint16_t val;
  if (params != NULL) {
    if (notInRange(params, 0, 1, val)) return;
    isTO = val ? true : false;
    if (isTO) isRO = false; // Read-only mode must be disabled in TO mode!
/*    
    if (isVerb) {
      dataStream.print(F("TON: "));
      dataStream.println(val ? "ON" : "OFF") ;
    }
*/    
  } else {
    dataStream.println(isTO);
  }
}


/***** Repeat a given command and return result *****/
void repeat_h(char *params) {

  uint16_t count;
  uint16_t tmdly;
  char *param;

  if (params != NULL) {
    // Count (number of repetitions)
    param = strtok(params, " \t");
    if (strlen(param) > 0) {
      if (notInRange(param, 2, 255, count)) return;
    }
    // Time delay (milliseconds)
    param = strtok(NULL, " \t");
    if (strlen(param) > 0) {
      if (notInRange(param, 0, 30000, tmdly)) return;
    }

    // Pointer to remainder of parameters string
    param = strtok(NULL, "\n\r");
    if (strlen(param) > 0) {
      for (uint16_t i = 0; i < count; i++) {
        // Send string to instrument
        gpibBus.sendData(param, strlen(param), true);
        delay(tmdly);
        gpibBus.receiveData(dataStream, gpibBus.cfg.eoi, false, 0);
      }
    } else {
      errBadCmd();
//      if (isVerb) dataStream.println(F("Missing parameter"));
      return;
    }
  } else {
    errBadCmd();
//    if (isVerb) dataStream.println(F("Missing parameters"));
  }

}


/***** Storage management *****/
#ifdef EN_STORAGE
/*
void store_h(char *params){
  char *keyword;
  char *param1;
  char *param2;
//  uint8_t mode = 0;
//  uint8_t val = 0;
  
  // Get first parameter (action)
  keyword = strtok(params, " \t");
  param1 = strtok(NULL, " \t");
  param2 = strtok(NULL, " \t");
  
  if (keyword != NULL) {
    if (strncmp(keyword, "info", 4)==0) {
      dataStream.print(F("SDcard initialised:\t"));
      if (storage.isInit()){
        dataStream.println(F("YES"));
        storage.showSDInfo(dataStream);
        dataStream.print(F("Volume mounted:\t\t"));
        if (storage.isVolumeMounted()){
          dataStream.println(F("YES"));
          storage.showSdVolumeInfo(dataStream);
        }else{
          dataStream.println(F("NO"));
        }
      }else{
        dataStream.println(F("NO"));
      }
    }

    if (strncmp(keyword, "dir", 4)==0) {
      storage.listSdFiles(dataStream);
    }

    if (strncmp(keyword, "fmt", 3)==0) {

    }

    if (strncmp(keyword, "tape", 4)==0) {
      tape_h(param1, param2);
    }
  }


}


void tape_h(char *cmd, char *param){
  
}
*/

#endif




/***** Bus diagnostics *****/
/*
 * Usage: xdiag mode byte
 * mode: 0=data bus; 1=control bus
 * byte: byte to write on the bus
 * Note: values to switch individual bits = 1,2,4,8,10,20,40,80
 */
void xdiag_h(char *params){
  char *param;
  uint8_t mode = 0;
  uint8_t val = 0;
  
  // Get first parameter (mode = 0 or 1)
  param = strtok(params, " \t");
  if (param != NULL) {
    if (strlen(param)<4){
      mode = atoi(param);
      if (mode>2) {
        dataStream.println(F("Invalid: 0=data bus; 1=control bus"));
        return;
      }
    }
  }
  // Get second parameter (8 bit byte)
  param = strtok(NULL, " \t");
  if (param != NULL) {
    if (strlen(param)<4){
      val = atoi(param);
    }

    if (mode) {   // Control bus
      // Set to required state
      gpibBus.setControlVal(0xFF, 0xFF, 1);  // Set direction
      gpibBus.setControlVal(~val, 0xFF, 0);  // Set state (low=asserted so must be inverse of value)
      // Reset after 10 seconds
      delay(10000);
/*      
      if (AR488.cmode==2) {
        setGpibControls(CINI);
      }else{
*/      
        gpibBus.setControls(DINI);
//      }
    }else{        // Data bus
      // Set to required value
      gpibBus.setDataVal(val);
      // Reset after 10 seconds
      delay(10000);
      gpibBus.setDataVal(0);
    }
  }

}


/****** Timing parameters ******/
/*
void tmbus_h(char *params) {
  uint16_t val;
  if (params != NULL) {
    if (notInRange(params, 0, 30000, val)) return;
    gpibBus.cfg.tmbus = val;
  
    if (isVerb) {
      dataStream.print(F("TmBus set to: "));
      dataStream.println(val);
    };
   
  } else {
    dataStream.println(gpibBus.cfg.tmbus, DEC);
  }
}
*/

/***** Set device ID *****/
/*
 * Sets the device ID parameters including:
 * ++id verstr - version string (same as ++setvstr)
 * ++id name   - short name of device (e.g. HP3478A) up to 15 characters
 * ++id serial - serial number up to 9 digits long
 */
void id_h(char *params) {
  uint8_t dlen = 0;
  char * keyword; // Pointer to keyword following ++id
  char * datastr; // Pointer to supplied data (remaining characters in buffer)
  char serialStr[10];

#ifdef DEBUG_IDFUNC
  dataStream.print(F("Params: "));
  dataStream.println(params);
#endif

  if (params != NULL) {
    keyword = strtok(params, " \t");
    datastr = keyword + strlen(keyword) + 1;
    dlen = strlen(datastr);
    if (dlen) {
      if (strncmp(keyword, "verstr", 6)==0) {
#ifdef DEBUG_IDFUNC      
        dataStream.print(F("Keyword: "));
        dataStream.println(keyword);
        dataStream.print(F("DataStr: "));
        dataStream.println(datastr);
#endif
        if (dlen>0 && dlen<48) {
#ifdef DEBUG_IDFUNC
        dataStream.println(F("Length OK"));
#endif
          memset(gpibBus.cfg.vstr, '\0', 48);
          strncpy(gpibBus.cfg.vstr, datastr, dlen);
//          if (isVerb) dataStream.print(F("VerStr: "));dataStream.println(AR488.vstr);
        }else{
//          if (isVerb) dataStream.println(F("Length of version string must not exceed 48 characters!"));
          errBadCmd();
        }
        return;
      }
      if (strncasecmp(keyword, "name", 4)==0) {
        if (dlen>0 && dlen<16) {
          memset(gpibBus.cfg.sname, '\0', 16);
          strncpy(gpibBus.cfg.sname, datastr, dlen);
        }else{
//          if (isVerb) dataStream.println(F("Length of name must not exceed 15 characters!"));
          errBadCmd();
        }
        return;
      }
      if (strncasecmp(keyword, "serial", 6)==0) {
        if (dlen < 10) {
          gpibBus.cfg.serial = atol(datastr);
        }else{
//          if (isVerb) dataStream.println(F("Serial number must not exceed 9 characters!"));
          errBadCmd();
        }
        return;
      }
//      errBadCmd();
    }else{
      if (strncasecmp(keyword, "verstr", 6)==0) {
        dataStream.println(gpibBus.cfg.vstr);
        return;
      }     
      if (strncasecmp(keyword, "name", 4)==0) {
        dataStream.println(gpibBus.cfg.sname);
        return;      
      }
      if (strncasecmp(keyword, "serial", 6)==0) {
        memset(serialStr, '\0', 10);
        snprintf(serialStr, 10, "%09lu", gpibBus.cfg.serial);  // Max str length = 10-1 i.e 9 digits + null terminator 
        dataStream.println(serialStr);
        return;    
      }
    }
  }
  errBadCmd();
}


void idn_h(char * params){
  uint16_t val;
  if (params != NULL) {
    if (notInRange(params, 0, 2, val)) return;
    gpibBus.cfg.idn = (uint8_t)val;
/*    
    if (isVerb) {
      dataStream.print(F("Sending IDN: "));
      dataStream.print(val ? "Enabled" : "Disabled"); 
      if (val==2) dataStream.print(F(" with serial number"));
      dataStream.println();
    };
*/    
  } else {
    dataStream.println(gpibBus.cfg.idn, DEC);
  }  
}


/******************************************************/
/***** Device mode GPIB command handling routines *****/
/******************************************************/

/***** Attention handling routine *****/
/*
 * In device mode is invoked whenever ATN is asserted
 */
void attnRequired() {

  uint8_t db = 0;
  uint8_t stat = 0;
//  bool mla = false;
//  bool mta = false;
//  bool spe = false;
//  bool spd = false;
  bool eoiDetected = false;
  uint8_t gpibcmd = 0;
  uint8_t saddrcmd = 0;

  // Set device listner active state (assert NDAC+NRFD (low), DAV=INPUT_PULLUP)
  gpibBus.setControls(DLAS);

#ifdef DEBUG_DEVICE_ATN
  debugStream.println(F("attnRequired: Answering attention!"));
#endif

  // Read bytes
  while (gpibBus.isAsserted(ATN)) {

#ifdef DEBUG_DEVICE_ATN
      debugStream.println(F("attnRequired: Reading byte..."));
#endif

    // Read the next byte from the bus, no EOI detection
    stat = gpibBus.readByte(&db, false, &eoiDetected);
    if (!stat) {

#ifdef DEBUG_DEVICE_ATN
      debugStream.println(db, HEX);
#endif

      // Device is addressed to listen
      if (gpibBus.cfg.paddr == (db ^ 0x20)) { // MLA = db^0x20
#ifdef DEBUG_DEVICE_ATN
        debugStream.println(F("attnRequired: Controller wants me to data accept data <<<"));
#endif
        gpibBus.setDeviceAddressedState(DLAS);

      // Device is addressed to talk
      }else if (gpibBus.cfg.paddr == (db ^ 0x40)) { // MLA = db^0x40
        // Call talk handler to send data
        gpibBus.setDeviceAddressedState(DTAS);
#ifdef DEBUG_DEVICE_ATN
        if (db != GC_SPE) debugStream.println(F("attnRequired: Controller wants me to send data >>>"));
#endif

#ifdef EN_STORAGE
      }else if (db>0x5F && db<0x80) {
        // Secondary addressing command received
        if (!gpibBus.isDeviceNotAddressed()) { // If we have been addressed
          saddrcmd = db;
  #ifdef DEBUG_DEVICE_ATN
          debugStream.print(F("attnRequired: Secondary addressing command received: "));
          debugStream.println(saddrcmd, HEX);
  #endif
        }
#endif        

      }else{
        if (!gpibBus.isDeviceNotAddressed()) { // If we have been addressed
          gpibcmd = db;
#ifdef DEBUG_DEVICE_ATN
          debugStream.print(F("attnRequired: GPIB command received: "));
          debugStream.println(gpibcmd, HEX);
#endif
        }
      }
    }
  }

#ifdef DEBUG_DEVICE_ATN
  debugStream.println(F("End ATN loop."));
#endif

/***** Perform GPIB copmmand actions *****/

  if (gpibcmd) {
    // Respond to GPIB command
    switch (db) {
      case GC_SPE:
        // Serial Poll enable request
#ifdef DEBUG_DEVICE_ATN
          debugStream.println(F("attnRequired: Received serial poll enable."));
#endif
          device_spe_h();
          break;
      case GC_SPD:
          // Serial poll disable request
#ifdef DEBUG_DEVICE_ATN
          debugStream.println(F("attnRequired: Received serial poll disable."));
#endif
          device_spd_h();
          break;
      case GC_UNL:
          // Unlisten
          device_unl_h();
          break;
      case GC_UNT:
          // Untalk
          device_unt_h();
          break;
      case GC_SDC:
          // Device clear (reset)
          device_sdc_h();
          break;
#ifdef PIN_REMOTE
      case GC_LLO:
          // Remote lockout mode
          device_llo_h();
          break;
      case GC_GTL:
          // Local mode
          device_gtl_h();
          break;
#endif
    } // End switch
    // Clear flags
    gpibcmd = 0;
    return;
  }


/***** Perform secondry address command actions *****/
#ifdef EN_STORAGE
  if (saddrcmd) {
    // If addressed to listen then set GPIB to listen
    if (gpibBus.isDeviceAddressedToListen()) gpibBus.setControls(DLAS);

    // If addressed to talk then set GPIB to talk
    if (gpibBus.isDeviceAddressedToTalk()) gpibBus.setControls(DTAS);
    
    // Execute the GPIB secondary addressing command
    storage.storeExecCmd(saddrcmd);
    // Clear flags
    saddrcmd = 0;

    // reset GPIB BUS back to idle
    gpibBus.setControls(DIDS);

    return;
  }

#endif


/***** Otherwise perform read or write *****/
  // Listen for data
  if (gpibBus.isDeviceAddressedToListen()) { 
#ifdef DEBUG_DEVICE_ATN
    debugStream.println(F("Listening..."));
#endif
    device_listen_h();
    return;
  }

  // Talk (send data)
  if (gpibBus.isDeviceAddressedToTalk()) {
#ifdef DEBUG_DEVICE_ATN
    debugStream.println(F("Talking..."));
#endif
    device_talk_h();
    return;
  }

  // Finished attention - set controls to idle
  gpibBus.setControls(DIDS);

#ifdef DEBUG_DEVICE_ATN
  debugStream.println(F("attnRequired: END attnReceived."));
#endif

}


/***** Device is addressed to listen - so listen *****/
void device_listen_h(){
  // Receivedata params: stream, detectEOI, detectEndByte, endByte
  gpibBus.receiveData(dataStream, false, false, 0x0);
}


/***** Device is addressed to talk - so send data *****/
void device_talk_h(){
  if (lnRdy == 2) sendToInstrument(pBuf, pbPtr);
}


/***** Selected Device Clear *****/
void device_sdc_h() {
  // If being addressed then reset
#ifdef DEBUG_DEVICE_ATN
  debugStream.print(F("device_sdc_h: Reset request received... "));
#endif
  rst_h();
#ifdef DEBUG_DEVICE_ATN
  // Shouldn't get here!
  debugStream.print(F("device_sdc_h: Reset failed!"));
#endif
}


/***** Serial Poll Disable *****/
void device_spd_h() {
#ifdef DEBUG_DEVICE_ATN
  debugStream.println(F("<- serial poll request ended."));
#endif
  gpibBus.setDeviceAddressedState(DIDS);
}


/***** Serial Poll Enable *****/
void device_spe_h() {
#ifdef DEBUG_DEVICE_ATN
  debugStream.println(F("Serial poll request received from controller ->"));
#endif
  gpibBus.sendStatus();
#ifdef DEBUG_DEVICE_ATN
  debugStream.println(F("Status sent."));
#endif
  // Check if SRQ bit is set and clear it
  if (gpibBus.cfg.stat & 0x40) {
    gpibBus.setStatus(gpibBus.cfg.stat & ~0x40);
#ifdef DEBUG_DEVICE_ATN
    debugStream.println(F("SRQ bit cleared."));
#endif
  }
}


/***** Unlisten *****/
void device_unl_h() {
  // Stop receiving and go to idle
#ifdef DEBUG_DEVICE_ATN
  debugStream.println(F("Unlisten received."));
#endif
  readWithEoi = false;
  // Immediate break - shouldn't ATN do this anyway?
  tranBrk = 3;  // Stop receving transmission
  // Clear addressed state flag and set controls to idle
  gpibBus.setDeviceAddressedState(DIDS);
  gpibBus.setControls(DIDS);
}


/***** Untalk *****/
void device_unt_h(){
  // Stop sending data and go to idle
#ifdef DEBUG_DEVICE_ATN
  debugStream.println(F("Untalk received."));
#endif
  // Clear addressed state flag and set controls to idle
  gpibBus.setDeviceAddressedState(DIDS);
  gpibBus.setControls(DIDS);
}


#ifdef REMOTE_SIGNAL_PIN
/***** Enabled remote mode *****/
void device_llo_h(){
  digitalWrite(PIN_REMOTE, HIGH);
}


/***** Disable remote mode *****/
void device_gtl_h(){
  digitalWrite(PIN_REMOTE, LOW);
}
#endif


/***** Listen only mode *****/
void lonMode(){
  // Receivedata params: stream, detectEOI, detectEndByte, endByte
  gpibBus.receiveData(dataStream, false, false, 0x0 );

  // Clear the buffer to prevent it getting blocked
  if (lnRdy==2) flushPbuf();
}
